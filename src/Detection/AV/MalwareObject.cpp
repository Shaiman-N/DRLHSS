/**
 * @file MalwareObject.cpp
 * @brief Implementation of MalwareObject class for DRLHSS
 */

#include "Detection/AV/MalwareObject.hpp"
#include "Detection/AV/FeatureExtractor.hpp"
#include "Detection/AV/BehaviorMonitor.hpp"
#include "Detection/AV/InferenceEngine.hpp"
#include <iostream>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <openssl/sha.h>

namespace drlhss {
namespace detection {
namespace av {

// Static ID counter
uint64_t MalwareObject::next_object_id_ = 1;

MalwareObject::MalwareObject(const std::string& target_path, 
                             bool enable_dynamic,
                             bool enable_drl)
    : target_path_(target_path)
    , object_id_(next_object_id_++)
    , current_phase_(AnalysisPhase::CREATED)
    , terminated_(false)
    , enable_dynamic_(enable_dynamic)
    , enable_drl_(enable_drl)
    , start_time_(std::chrono::steady_clock::now())
{
    file_hash_ = calculateFileHash();
    
    std::cout << "[MalwareObject " << object_id_ << "] Created for: " 
              << target_path_ << std::endl;
    std::cout << "[MalwareObject " << object_id_ << "] Hash: " 
              << file_hash_.substr(0, 16) << "..." << std::endl;
}

MalwareObject::~MalwareObject() {
    if (!terminated_) {
        terminate();
    }
}

bool MalwareObject::analyze() {
    if (terminated_) {
        std::cerr << "[MalwareObject " << object_id_ << "] Already terminated" << std::endl;
        return false;
    }
    
    std::cout << "[MalwareObject " << object_id_ << "] Starting analysis..." << std::endl;
    
    // Phase 1: Static Analysis
    if (!analyzeStatic()) {
        std::cerr << "[MalwareObject " << object_id_ << "] Static analysis failed" << std::endl;
        return false;
    }
    
    // Phase 2: Dynamic Analysis (if enabled)
    if (enable_dynamic_) {
        if (!analyzeDynamic()) {
            std::cerr << "[MalwareObject " << object_id_ << "] Dynamic analysis failed" << std::endl;
            // Continue even if dynamic fails
        }
    }
    
    // Phase 3: DRL Analysis (if enabled)
    if (enable_drl_) {
        if (!analyzeDRL()) {
            std::cerr << "[MalwareObject " << object_id_ << "] DRL analysis failed" << std::endl;
            // Continue even if DRL fails
        }
    }
    
    // Calculate combined score
    calculateCombinedScore();
    determineThreatLevel();
    
    // Calculate duration
    auto end_time = std::chrono::steady_clock::now();
    result_.analysis_duration = std::chrono::duration_cast<std::chrono::milliseconds>(
        end_time - start_time_
    );
    
    updatePhase(AnalysisPhase::COMPLETED);
    
    std::cout << "[MalwareObject " << object_id_ << "] Analysis complete: " 
              << result_.verdict << " (" << result_.combined_score << ")" << std::endl;
    
    return true;
}

bool MalwareObject::analyzeStatic() {
    updatePhase(AnalysisPhase::STATIC_ANALYSIS);
    
    std::cout << "[MalwareObject " << object_id_ << "] Extracting PE features..." << std::endl;
    
    // Extract features
    FeatureExtractor extractor;
    static_features_ = extractor.extract(target_path_);
    
    if (static_features_.empty()) {
        std::cerr << "[MalwareObject " << object_id_ << "] Feature extraction failed: " 
                  << extractor.getLastError() << std::endl;
        return false;
    }
    
    std::cout << "[MalwareObject " << object_id_ << "] Extracted " 
              << static_features_.size() << " features" << std::endl;
    
    // Perform inference
    InferenceEngine inference;
    if (!inference.loadStaticModel("models/onnx/antivirus_static_model.onnx")) {
        std::cerr << "[MalwareObject " << object_id_ << "] Failed to load static model: "
                  << inference.getLastError() << std::endl;
        return false;
    }
    
    auto prediction = inference.predictStatic(static_features_);
    result_.static_confidence = prediction.confidence;
    
    std::cout << "[MalwareObject " << object_id_ << "] Static confidence: " 
              << result_.static_confidence << "%" << std::endl;
    
    return true;
}

bool MalwareObject::analyzeDynamic() {
    updatePhase(AnalysisPhase::DYNAMIC_ANALYSIS);
    
    std::cout << "[MalwareObject " << object_id_ << "] Starting behavior monitoring..." << std::endl;
    
    // Monitor behavior
    BehaviorMonitor monitor;
    if (!monitor.executeAndMonitor(target_path_, 15)) {
        std::cerr << "[MalwareObject " << object_id_ << "] Behavior monitoring failed: " 
                  << monitor.getLastError() << std::endl;
        return false;
    }
    
    // Extract features
    dynamic_features_ = monitor.extractFeatures();
    
    if (dynamic_features_.empty()) {
        std::cerr << "[MalwareObject " << object_id_ << "] Dynamic feature extraction failed" << std::endl;
        return false;
    }
    
    std::cout << "[MalwareObject " << object_id_ << "] Extracted " 
              << dynamic_features_.size() << " behavioral features" << std::endl;
    
    // Perform inference
    InferenceEngine inference;
    if (!inference.loadDynamicModel("models/onnx/antivirus_dynamic_model.onnx")) {
        std::cerr << "[MalwareObject " << object_id_ << "] Failed to load dynamic model: "
                  << inference.getLastError() << std::endl;
        return false;
    }
    
    auto prediction = inference.predictDynamic(dynamic_features_);
    result_.dynamic_confidence = prediction.confidence;
    
    // Store behavioral indicators
    auto behavior_data = monitor.getBehaviorData();
    if (behavior_data.network_connections > 5) {
        result_.indicators.push_back("Multiple network connections");
    }
    if (behavior_data.child_processes > 2) {
        result_.indicators.push_back("Multiple child processes");
    }
    if (behavior_data.max_cpu_percent > 70.0f) {
        result_.indicators.push_back("High CPU usage");
    }
    
    std::cout << "[MalwareObject " << object_id_ << "] Dynamic confidence: " 
              << result_.dynamic_confidence << "%" << std::endl;
    
    return true;
}

bool MalwareObject::analyzeDRL() {
    updatePhase(AnalysisPhase::DRL_INFERENCE);
    
    std::cout << "[MalwareObject " << object_id_ << "] Performing DRL inference..." << std::endl;
    
    // DRL inference would be performed by the bridge
    // This is a placeholder for the MalwareObject's perspective
    
    return true;
}

bool MalwareObject::sendToSandbox() {
    if (terminated_) {
        return false;
    }
    
    updatePhase(AnalysisPhase::SANDBOX_PENDING);
    
    std::cout << "[MalwareObject " << object_id_ << "] Sending to sandbox..." << std::endl;
    
    // Sandbox integration handled by bridge
    
    return true;
}

bool MalwareObject::waitForSandboxResult() {
    std::cout << "[MalwareObject " << object_id_ << "] Waiting for sandbox result..." << std::endl;
    return true;
}

bool MalwareObject::isMalicious() const {
    return result_.threat_level == ThreatLevel::MALICIOUS;
}

bool MalwareObject::isSuspicious() const {
    return result_.threat_level == ThreatLevel::SUSPICIOUS;
}

bool MalwareObject::isAnalysisComplete() const {
    return current_phase_ == AnalysisPhase::COMPLETED;
}

ThreatLevel MalwareObject::getThreatLevel() const {
    return result_.threat_level;
}

AnalysisPhase MalwareObject::getCurrentPhase() const {
    return current_phase_;
}

const AnalysisResult& MalwareObject::getResult() const {
    return result_;
}

std::string MalwareObject::getReport() const {
    std::ostringstream report;
    
    report << "=== Malware Analysis Report ===" << std::endl;
    report << "Object ID: " << object_id_ << std::endl;
    report << "Target: " << target_path_ << std::endl;
    report << "Hash: " << file_hash_ << std::endl;
    report << "Verdict: " << result_.verdict << std::endl;
    report << "Threat Level: " << static_cast<int>(result_.threat_level) << std::endl;
    report << "Static Confidence: " << result_.static_confidence << "%" << std::endl;
    
    if (enable_dynamic_) {
        report << "Dynamic Confidence: " << result_.dynamic_confidence << "%" << std::endl;
    }
    
    if (enable_drl_) {
        report << "DRL Action: " << result_.drl_action << std::endl;
        report << "DRL Confidence: " << result_.drl_confidence << "%" << std::endl;
    }
    
    report << "Combined Score: " << result_.combined_score << std::endl;
    report << "Analysis Duration: " << result_.analysis_duration.count() << "ms" << std::endl;
    
    if (!result_.indicators.empty()) {
        report << "Indicators:" << std::endl;
        for (const auto& indicator : result_.indicators) {
            report << "  - " << indicator << std::endl;
        }
    }
    
    return report.str();
}

void MalwareObject::terminate() {
    if (terminated_) {
        return;
    }
    
    std::cout << "[MalwareObject " << object_id_ << "] Terminating..." << std::endl;
    
    updatePhase(AnalysisPhase::TERMINATED);
    terminated_ = true;
    
    // Cleanup resources
    static_features_.clear();
    dynamic_features_.clear();
    
    std::cout << "[MalwareObject " << object_id_ << "] Terminated" << std::endl;
}

bool MalwareObject::isTerminated() const {
    return terminated_;
}

void MalwareObject::updatePhase(AnalysisPhase phase) {
    current_phase_ = phase;
}

void MalwareObject::calculateCombinedScore() {
    float score = 0.0f;
    float weight_sum = 0.0f;
    
    // Static analysis (weight: 0.5)
    if (result_.static_confidence > 0.0f) {
        score += result_.static_confidence * 0.5f;
        weight_sum += 0.5f;
    }
    
    // Dynamic analysis (weight: 0.3)
    if (enable_dynamic_ && result_.dynamic_confidence > 0.0f) {
        score += result_.dynamic_confidence * 0.3f;
        weight_sum += 0.3f;
    }
    
    // DRL analysis (weight: 0.2)
    if (enable_drl_ && result_.drl_confidence > 0.0f) {
        score += result_.drl_confidence * 0.2f;
        weight_sum += 0.2f;
    }
    
    // Normalize
    if (weight_sum > 0.0f) {
        result_.combined_score = score / weight_sum;
    } else {
        result_.combined_score = result_.static_confidence;
    }
}

void MalwareObject::determineThreatLevel() {
    if (result_.combined_score >= 70.0f) {
        result_.threat_level = ThreatLevel::MALICIOUS;
        result_.verdict = "MALICIOUS";
    } else if (result_.combined_score >= 40.0f) {
        result_.threat_level = ThreatLevel::SUSPICIOUS;
        result_.verdict = "SUSPICIOUS";
    } else {
        result_.threat_level = ThreatLevel::BENIGN;
        result_.verdict = "BENIGN";
    }
}

std::string MalwareObject::calculateFileHash() {
    std::ifstream file(target_path_, std::ios::binary);
    if (!file.is_open()) {
        return "";
    }
    
    SHA256_CTX sha256;
    SHA256_Init(&sha256);
    
    char buffer[8192];
    while (file.read(buffer, sizeof(buffer))) {
        SHA256_Update(&sha256, buffer, file.gcount());
    }
    
    unsigned char hash[SHA256_DIGEST_LENGTH];
    SHA256_Final(hash, &sha256);
    
    std::stringstream ss;
    for (int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
        ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(hash[i]);
    }
    
    return ss.str();
}

} // namespace av
} // namespace detection
} // namespace drlhss
