#include "MalwareDetectionService.h"
#include <iostream>
#include <chrono>

MalwareDetectionService::MalwareDetectionService(
    const std::string& modelPath,
    const std::string& databasePath)
    : running_(false) {
    
    std::cout << "[Service] Initializing Malware Detection Service with Dual Sandbox System..." << std::endl;
    
    // Create the shared detector instance
    detector_ = std::make_shared<MalwareDetector>(modelPath);
    
    // Create DRL Framework
    drlFramework_ = std::make_shared<DRLFramework>(databasePath);
    
    // Create Sandbox Orchestrator
    orchestrator_ = std::make_shared<SandboxOrchestrator>(drlFramework_);
    
    // Create Processing Pipeline
    pipeline_ = std::make_shared<MalwareProcessingPipeline>(detector_, orchestrator_, drlFramework_);
    
    std::cout << "[Service] Service initialized successfully" << std::endl;
}

MalwareDetectionService::~MalwareDetectionService() {
    stop();
}

void MalwareDetectionService::start() {
    if (running_) {
        std::cout << "[Service] Service already running" << std::endl;
        return;
    }
    
    std::cout << "[Service] Starting background service..." << std::endl;
    running_ = true;
    
    // Start worker thread
    workerThread_ = std::thread(&MalwareDetectionService::workerLoop, thi
s);
    
    std::cout << "[Service] Background service started" << std::endl;
}

void MalwareDetectionService::stop() {
    if (!running_) {
        return;
    }
    
    std::cout << "[Service] Stopping background service..." << std::endl;
    running_ = false;
    
    // Wake up worker thread
    queueCondition_.notify_all();
    
    // Wait for worker thread to finish
    if (workerThread_.joinable()) {
        workerThread_.join();
    }
    
    std::cout << "[Service] Background service stopped" << std::endl;
}

void MalwareDetectionService::queueFileScan(const std::string& filePath) {
    ScanTask task;
    task.filePath = filePath;
    task.isFile = true;
    
    {
        std::lock_guard<std::mutex> lock(queueMutex_);
        taskQueue_.push(task);
        std::cout << "[Service] Queued file scan: " << filePath << std::endl;
    }
    
    queueCondition_.notify_one();
}

void MalwareDetectionService::queueDataPacketScan(const std::vector<uint8_t>& packet) {
    ScanTask task;
    task.data = packet;
    task.isFile = false;
    
    {
        std::lock_guard<std::mutex> lock(queueMutex_);
        taskQueue_.push(task);
        std::cout << "[Service] Queued data packet scan (" << packet.size() << " bytes)" << std::endl;
    }
    
    queueCondition_.notify_one();
}

void MalwareDetectionService::workerLoop() {
    std::cout << "[Service] Worker thread started" << std::endl;
    
    while (running_) {
        ScanTask task;
        
        {
            std::unique_lock<std::mutex> lock(queueMutex_);
            
            // Wait for tasks or stop signal
            queueCondition_.wait(lock, [this] {
                return !taskQueue_.empty() || !running_;
            });
            
            // Check if we should exit
            if (!running_ && taskQueue_.empty()) {
                break;
            }
            
            // Get next task
            if (!taskQueue_.empty()) {
                task = taskQueue_.front();
                taskQueue_.pop();
            } else {
                continue;
            }
        }
        
        // Process the task
        processScanTask(task);
    }
    
    std::cout << "[Service] Worker thread stopped" << std::endl;
}

void MalwareDetectionService::processScanTask(const ScanTask& task) {
    std::cout << "[Service] Processing scan task..." << std::endl;
    
    // Create a MalwareObject for this scan
    auto malwareObject = std::make_unique<MalwareObject>(pipeline_);
    
    bool success = false;
    if (task.isFile) {
        success = malwareObject->scanFile(task.filePath);
    } else {
        success = malwareObject->scanDataPacket(task.data);
    }
    
    if (success) {
        PipelineResult result = malwareObject->getPipelineResult();
        
        if (!result.isSafe) {
            std::cout << "[Service] ⚠️  THREATS DETECTED!" << std::endl;
            std::cout << "[Service] Threats found: " << result.detectedThreats.size() << std::endl;
            for (const auto& threat : result.detectedThreats) {
                std::cout << "[Service]   - " << threat << std::endl;
            }
            if (task.isFile) {
                std::cout << "[Service] File: " << malwareObject->getFilePath() << std::endl;
            }
        } else {
            std::cout << "[Service] ✓ Processing complete - File is SAFE" << std::endl;
            std::cout << "[Service] Cleaned data sent to host system" << std::endl;
        }
    } else {
        std::cerr << "[Service] Processing failed" << std::endl;
    }
    
    // Terminate the malware object (cleanup)
    malwareObject->terminate();
    
    std::cout << "[Service] Task completed and cleaned up" << std::endl;
}
