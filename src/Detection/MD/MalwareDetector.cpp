#include "MalwareDetector.h"
#include <iostream>
#include <fstream>
#include <algorithm>

MalwareDetector::MalwareDetector(const std::string& modelPath) {
    try {
        // Initialize ONNX Runtime environment
        env_ = std::make_unique<Ort::Env>(ORT_LOGGING_LEVEL_WARNING, "MalwareDetection");
        
        // Create session options
        sessionOptions_ = std::make_unique<Ort::SessionOptions>();
        sessionOptions_->SetIntraOpNumThreads(1);
        sessionOptions_->SetGraphOptimizationLevel(GraphOptimizationLevel::ORT_ENABLE_EXTENDED);
        
        // Load the model
#ifdef _WIN32
        std::wstring wideModelPath(modelPath.begin(), modelPath.end());
        session_ = std::make_unique<Ort::Session>(*env_, wideModelPath.c_str(), *sessionOptions_);
#else
        session_ = std::make_unique<Ort::Session>(*env_, modelPath.c_str(), *sessionOptions_);
#endif
        
        // Get input/output information
        Ort::AllocatorWithDefaultOptions allocator;
        
        // Input info
        size_t numInputNodes = session_->GetInputCount();
        for (size_t i = 0; i < numInputNodes; i++) {
            auto inputName = session_->GetInputNameAllocated(i, allocator);
            inputNames_.push_back(inputName.get());
        }
        
        // Get input shape
        auto inputTypeInfo = session_->GetInputTypeInfo(0);
        auto tensorInfo = inputTypeInfo.GetTensorTypeAndShapeInfo();
        inputShape_ = tensorInfo.GetShape();
        
        // Output info
        size_t numOutputNodes = session_->GetOutputCount();
        for (size_t i = 0; i < numOutputNodes; i++) {
            auto outputName = session_->GetOutputNameAllocated(i, allocator);
            outputNames_.push_back(outputName.get());
        }
        
        std::cout << "Model loaded successfully: " << modelPath << std::endl;
        std::cout << "Input shape: [";
        for (size_t i = 0; i < inputShape_.size(); i++) {
            std::cout << inputShape_[i];
            if (i < inputShape_.size() - 1) std::cout << ", ";
        }
        std::cout << "]" << std::endl;
        
    } catch (const Ort::Exception& e) {
        std::cerr << "Error loading model: " << e.what() << std::endl;
        throw;
    }
}

MalwareDetector::~MalwareDetector() {
    // Cleanup handled by unique_ptr
}

bool MalwareDetector::detectMalware(const std::vector<uint8_t>& data, float& confidence) {
    try {
        // Preprocess the data
        std::vector<float> inputTensor = preprocessData(data);
        
        // Create input tensor
        auto memoryInfo = Ort::MemoryInfo::CreateCpu(OrtArenaAllocator, OrtMemTypeDefault);
        Ort::Value inputOrtTensor = Ort::Value::CreateTensor<float>(
            memoryInfo,
            inputTensor.data(),
            inputTensor.size(),
            inputShape_.data(),
            inputShape_.size()
        );
        
        // Run inference
        auto outputTensors = session_->Run(
            Ort::RunOptions{nullptr},
            inputNames_.data(),
            &inputOrtTensor,
            1,
            outputNames_.data(),
            outputNames_.size()
        );
        
        // Get output
        float* outputData = outputTensors[0].GetTensorMutableData<float>();
        confidence = outputData[0];
        
        // Threshold for malware detection (adjust as needed)
        const float MALWARE_THRESHOLD = 0.5f;
        
        return confidence >= MALWARE_THRESHOLD;
        
    } catch (const Ort::Exception& e) {
        std::cerr << "Error during inference: " << e.what() << std::endl;
        confidence = 0.0f;
        return false;
    }
}

std::vector<float> MalwareDetector::preprocessData(const std::vector<uint8_t>& data) {
    // Calculate expected input size
    int64_t expectedSize = 1;
    for (size_t i = 1; i < inputShape_.size(); i++) {
        if (inputShape_[i] > 0) {
            expectedSize *= inputShape_[i];
        }
    }
    
    std::vector<float> processed(expectedSize, 0.0f);
    
    // Normalize byte values to [0, 1]
    size_t copySize = std::min(static_cast<size_t>(expectedSize), data.size());
    for (size_t i = 0; i < copySize; i++) {
        processed[i] = static_cast<float>(data[i]) / 255.0f;
    }
    
    return processed;
}

std::string MalwareDetector::getModelInfo() const {
    std::string info = "Model Information:\n";
    info += "Input nodes: " + std::to_string(inputNames_.size()) + "\n";
    info += "Output nodes: " + std::to_string(outputNames_.size()) + "\n";
    info += "Input shape: [";
    for (size_t i = 0; i < inputShape_.size(); i++) {
        info += std::to_string(inputShape_[i]);
        if (i < inputShape_.size() - 1) info += ", ";
    }
    info += "]\n";
    return info;
}
