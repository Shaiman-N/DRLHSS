#include "MalwareProcessingPipeline.h"
#include <iostream>
#include <fstream>
#include <filesystem>

namespace fs = std::filesystem;

MalwareProcessingPipeline::MalwareProcessingPipeline(
    std::shared_ptr<MalwareDetector> detector,
    std::shared_ptr<SandboxOrchestrator> orchestrator,
    std::shared_ptr<DRLFramework> drlFramework)
    : detector_(detector),
      orchestrator_(orchestrator),
      drlFramework_(drlFramework) {
    
    std::cout << "[Pipeline] Malware Processing Pipeline initialized" << std::endl;
}

MalwareProcessingPipeline::~MalwareProcessingPipeline() {
    std::cout << "[Pipeline] Shutting down" << std::endl;
}

PipelineResult MalwareProcessingPipeline::processFile(const std::string& filePath) {
    std::cout << "\n========================================" << std::endl;
    std::cout << "[Pipeline] Processing file: " << filePath << std::endl;
    std::cout << "========================================\n" << std::endl;
    
    PipelineResult result;
    result.isSafe = false;
    result.finalStage = PipelineStage::INITIAL_DETECTION;
    
    // STAGE 1: Initial Detection
    logPipelineProgress(PipelineStage::INITIAL_DETECTION, filePath);
    
    float confidence = 0.0f;
    bool malwareDetected = performInitialDetection(filePath, confidence);
    
    if (malwareDetected) {
        std::cout << "[Pipeline] ⚠️  MALWARE DETECTED in initial scan (Confidence: " 
                  << confidence << ")" << std::endl;
        std::cout << "[Pipeline] → Routing to POSITIVE SANDBOX" << std::endl;
        
        // STAGE 2: Positive Sandbox Processing
        result = processWithPositiveSandbox(filePath);
        
        if (result.finalStage == PipelineStage::ERROR) {
            return result;
        }
        
        // STAGE 3: Negative Sandbox (after positive sandbox cleaning)
        std::cout << "[Pipeline] → Routing cleaned file to NEGATIVE SANDBOX for false negative check" << std::endl;
        result = processWithNegativeSandbox(filePath, true);
        
    } else {
        std::cout << "[Pipeline] ✓ No malware detected in initial scan" << std::endl;
        std::cout << "[Pipeline] → Routing directly to NEGATIVE SANDBOX for false negative check" << std::endl;
        
        // STAGE 2: Negative Sandbox (direct route)
        result = processWithNegativeSandbox(filePath, false);
    }
    
    // Final stage: Send to host system
    if (result.isSafe) {
        std::cout << "\n[Pipeline] ✓ File is CLEAN - Sending to host system" << std::endl;
        sendToHostSystem(result.cleanedData);
        result.finalStage = PipelineStage::COMPLETED;
    }
    
    std::cout << "\n========================================" << std::endl;
    std::cout << "[Pipeline] Processing completed" << std::endl;
    std::cout << "========================================\n" << std::endl;
    
    return result;
}

PipelineResult MalwareProcessingPipeline::processDataPacket(const std::vector<uint8_t>& packet) {
    std::cout << "[Pipeline] Processing data packet (" << packet.size() << " bytes)" << std::endl;
    
    // Save packet to temporary file for processing
    std::string tempFile = "temp_packet_" + std::to_string(std::time(nullptr)) + ".bin";
    std::ofstream file(tempFile, std::ios::binary);
    file.write(reinterpret_cast<const char*>(packet.data()), packet.size());
    file.close();
    
    // Process through pipeline
    PipelineResult result = processFile(tempFile);
    
    // Clean up temp file
    try {
        fs::remove(tempFile);
    } catch (...) {}
    
    return result;
}

bool MalwareProcessingPipeline::sendToHostSystem(const std::vector<uint8_t>& cleanedData) {
    std::cout << "[Pipeline] Sending cleaned data to host system..." << std::endl;
    std::cout << "[Pipeline] Data size: " << cleanedData.size() << " bytes" << std::endl;
    
    // In production, this would:
    // - Send data to the actual host system
    // - Update system logs
    // - Notify monitoring systems
    // - Update statistics
    
    std::cout << "[Pipeline] ✓ Data successfully delivered to host system" << std::endl;
    return true;
}

bool MalwareProcessingPipeline::performInitialDetection(const std::string& filePath, float& confidence) {
    std::ifstream file(filePath, std::ios::binary);
    if (!file.is_open()) {
        std::cerr << "[Pipeline] Error: Cannot open file for detection" << std::endl;
        return false;
    }
    
    std::vector<uint8_t> fileData((std::istreambuf_iterator<char>(file)),
                                   std::istreambuf_iterator<char>());
    
    return detector_->detectMalware(fileData, confidence);
}

PipelineResult MalwareProcessingPipeline::processWithPositiveSandbox(const std::string& filePath) {
    PipelineResult result;
    result.finalStage = PipelineStage::POSITIVE_SANDBOX;
    
    logPipelineProgress(PipelineStage::POSITIVE_SANDBOX, filePath);
    
    // Run in positive sandbox
    SandboxAnalysisResult sandboxResult = orchestrator_->runInPositiveSandbox(filePath);
    
    if (sandboxResult.result == SandboxResult::ERROR) {
        std::cerr << "[Pipeline] Error in positive sandbox execution" << std::endl;
        result.finalStage = PipelineStage::ERROR;
        return result;
    }
    
    if (sandboxResult.result == SandboxResult::MALWARE_DETECTED) {
        std::cout << "[Pipeline] ⚠️  Malware confirmed in positive sandbox" << std::endl;
        std::cout << "[Pipeline] Attack patterns: " << sandboxResult.attackPatterns.size() << std::endl;
        std::cout << "[Pipeline] Threat score: " << sandboxResult.threatScore << std::endl;
        
        result.detectedThreats.insert(result.detectedThreats.end(),
                                     sandboxResult.attackPatterns.begin(),
                                     sandboxResult.attackPatterns.end());
        
        // Clean or delete the file
        std::cout << "[Pipeline] Cleaning/deleting malicious content..." << std::endl;
        if (!orchestrator_->cleanOrDeleteFile(filePath, sandboxResult)) {
            std::cerr << "[Pipeline] Error cleaning file" << std::endl;
            result.finalStage = PipelineStage::ERROR;
            return result;
        }
        
        std::cout << "[Pipeline] ✓ File cleaned successfully" << std::endl;
    }
    
    // Get cleaned data
    result.cleanedData = orchestrator_->getCleanedDataPacket(filePath);
    
    return result;
}

PipelineResult MalwareProcessingPipeline::processWithNegativeSandbox(
    const std::string& filePath,
    bool fromPositive) {
    
    PipelineResult result;
    result.finalStage = PipelineStage::NEGATIVE_SANDBOX;
    
    logPipelineProgress(PipelineStage::NEGATIVE_SANDBOX, filePath);
    
    if (fromPositive) {
        std::cout << "[Pipeline] Checking cleaned file for remaining threats..." << std::endl;
    } else {
        std::cout << "[Pipeline] Checking for false negatives..." << std::endl;
    }
    
    // Run in negative sandbox
    SandboxAnalysisResult sandboxResult = orchestrator_->runInNegativeSandbox(filePath);
    
    if (sandboxResult.result == SandboxResult::ERROR) {
        std::cerr << "[Pipeline] Error in negative sandbox execution" << std::endl;
        result.finalStage = PipelineStage::ERROR;
        return result;
    }
    
    if (sandboxResult.result == SandboxResult::MALWARE_DETECTED) {
        std::cout << "[Pipeline] ⚠️  FALSE NEGATIVE DETECTED!" << std::endl;
        std::cout << "[Pipeline] Attack patterns: " << sandboxResult.attackPatterns.size() << std::endl;
        std::cout << "[Pipeline] Threat score: " << sandboxResult.threatScore << std::endl;
        
        result.detectedThreats.insert(result.detectedThreats.end(),
                                     sandboxResult.attackPatterns.begin(),
                                     sandboxResult.attackPatterns.end());
        
        // Clean or delete the file
        std::cout << "[Pipeline] Cleaning/deleting malicious content..." << std::endl;
        if (!orchestrator_->cleanOrDeleteFile(filePath, sandboxResult)) {
            std::cerr << "[Pipeline] Error cleaning file" << std::endl;
            result.finalStage = PipelineStage::ERROR;
            return result;
        }
        
        std::cout << "[Pipeline] ✓ File cleaned successfully" << std::endl;
        result.isSafe = true;
    } else {
        std::cout << "[Pipeline] ✓ No threats detected in negative sandbox" << std::endl;
        result.isSafe = true;
    }
    
    // Get final cleaned data
    result.cleanedData = orchestrator_->getCleanedDataPacket(filePath);
    result.report = generateReport(result.detectedThreats, result.finalStage);
    
    return result;
}

std::string MalwareProcessingPipeline::generateReport(
    const std::vector<std::string>& threats,
    PipelineStage stage) {
    
    std::stringstream report;
    report << "=== MALWARE PROCESSING REPORT ===" << std::endl;
    report << "Final Stage: ";
    
    switch (stage) {
        case PipelineStage::INITIAL_DETECTION:
            report << "Initial Detection" << std::endl;
            break;
        case PipelineStage::POSITIVE_SANDBOX:
            report << "Positive Sandbox" << std::endl;
            break;
        case PipelineStage::NEGATIVE_SANDBOX:
            report << "Negative Sandbox" << std::endl;
            break;
        case PipelineStage::COMPLETED:
            report << "Completed" << std::endl;
            break;
        case PipelineStage::ERROR:
            report << "Error" << std::endl;
            break;
    }
    
    report << "Threats Detected: " << threats.size() << std::endl;
    for (const auto& threat : threats) {
        report << "  - " << threat << std::endl;
    }
    
    return report.str();
}

void MalwareProcessingPipeline::logPipelineProgress(
    PipelineStage stage,
    const std::string& filePath) {
    
    std::cout << "\n[Pipeline] ═══════════════════════════════" << std::endl;
    
    switch (stage) {
        case PipelineStage::INITIAL_DETECTION:
            std::cout << "[Pipeline] STAGE 1: Initial Detection" << std::endl;
            break;
        case PipelineStage::POSITIVE_SANDBOX:
            std::cout << "[Pipeline] STAGE 2: Positive Sandbox Analysis" << std::endl;
            break;
        case PipelineStage::NEGATIVE_SANDBOX:
            std::cout << "[Pipeline] STAGE 3: Negative Sandbox Analysis" << std::endl;
            break;
        default:
            break;
    }
    
    std::cout << "[Pipeline] ═══════════════════════════════\n" << std::endl;
}
